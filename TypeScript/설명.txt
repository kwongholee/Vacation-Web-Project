typescript == javascript + Type 문법 == 자바스크립트 업글버전
자바스크립트는 dynamic typing이 가능해서 편리하긴 한데
프로젝트 사이즈가 커지면 문제임
코드 길게 짤 때 자유도와 유연성이 높을수록 좋지 않음
그리고 타입스크립트는 에러메세지의 퀄리티가 오짐
근데 사실 타입스크립트는 코드 에디터 부가 기능과 비슷함
타입스크립트 쓸려면 1. node.js 설치하고 2. 터미널에 npm install -g typescript 적어보셈
3. 파일 확장자는 .ts로 마무리하면 되고 4. tsconfig.json이라는 파일 생성해서 기본 셋팅도 마무리해야함
.ts 파일은 브라우저가 못 읽기 때문에 js파일로 변환시켜야함
터미널 켜서 tsc -w 입력해두면 알아서 자동변환해줌 (컴파일)
변수 설정시 :타입명으로 변수의 타입을 지정할 수 있음
변수 타입이 Array일 때는 ':어레이안에들어갈타입명[]'로 지정하면 됨
타입이 Object이면 ':{key: 타입명}'로 지정하면 됨 key뒤에 ?를 붙이면 옵션으로 들어와도 되고 안들어와도 되는 것을 설정할 수 있음
다양한 타입을 가능하게 하고 싶으면 | 연산자 사용 (Union type)
타입은 변수에 담아서 사용할 수 있음 (type alias) => 보통 type명 작성할 때는 첫글자 대문자
함수의 파라미터도 똑같이 설정할 수 있으며, return 값의 type을 검사하고 싶으면 파라미터 옆에 똑같이 설정할 수 있음
array에 쓸 수 있는 타입을 지정할 수 있음(tuple 타입) - 순서에 따라 지정할 수 있음 (ex> [number, boolean] ==> 무조건 첫 번째는 number, 두 번째는 boolean 이어야함)
Object에 타입 지정해야할 속성이 너무 많으면 key랑 value만 따로 지정 가능
class도 타입 지정 가능

tsconfig.json 추가 설정
noImplicityAny는 any라는 타입이 의도치 않게 발생하면 에러 띄워주는 설정
strictNullChecks는 null, undefined 타입에 이상한 조작하면 에러 띄워주는 설정임
나머지 부가 설정들은 tsconfig.json 내리면 있음 확인해보셈

JS 문법 그대로 TS에서 사용 가능함
변수에 타입을 지정한다 == 변수에 쉴드를 씌워준다
타입에는 undefined나 null도 있음
어레이 안에 여러 자료형을 같이 넣고 싶으면 union type 쓰세염
타입스크립트 갓 배운 사람들이 온갖 곳에 다 타입 지정하는데 사실 타입 지정은 원래 자동으로 됨
따라서 타입지정 문법 생략해도 됨

타입 지정에 조건을 여러 개를 못 두나요?
둘 수 있음 | 쓰던가 'Union 타입'이라고 부름
소괄호로 묶어서 보기 좋게 해도 됨 (자료형1 | 자료형2 | 자료형3 ....)
근데 union 타입으로 묶고 변수 선언을 하면 타입이 하나로 지정됨
근데 재할당하면 다시 union 타입으로 바뀜
array나 object에 여러 타입 지정하고 싶으면 union type으로 묶어도 되고
아니면 any 타입 설정하든가
any 타입은 모든 자료형을 다 허용해줌
근데 그러면 타입스크립트 쓰는 이유가 없어지지 않음? 맞음
any 타입은 타입 지정 쉴드를 없애주세요라고 하는 거랑 같음
그래서 기본적으로는 타입 지정하지 말고 걍 js 문법으로 변수 설정하든가
unknown 타입도 있음 얘도 모든 자료형을 허용해줌
unknown 타입이 any 타입보다 안전함 왜?
any 타입은 아예 쉴드 자체가 없지만 unknown 타입은 쉴드가 있어서 조금 더 엄격함
타입스크립트는 js보다 휠씬 엄격함
간단한 연산도 피연산자 타입이 일치해야 함
유니온 타입 변수에 값을 할당하지 않은 상태라면 연산이 불가능함
당연히 unknown 타입으로 지정한 변수도 연산이 가능하겠음? 불가능함
(강조) 타입스크립트는 타입에 굉장히 엄격함

변수만 따로 설정하면 any 타입으로 할당됨
그래서 파라미터도 똑같은 방법으로 타입 설정이 가능함
return 값도 똑같이 타입 설정 가능함
함수에서는 특별하게 void라는 타입도 존재함
void 타입을 지정하면 return 값이 존재하지 않는 함수가 되어버림
타입 지정된 파라미터는 무조건 함수 사용 시 적어야 함 (자바스크립트는 안 써도 됨)
파라미터가 옵션이라면 파라미터? :타입명으로 선언하셈
?의 정확한 뜻은 | undefined랑 같은 거임
애매한 타입들은 미리 타입을 검사하는 것이 필요함

type이 아직 하나로 확정되지 않은 경우엔 type narrowing 써야함
typeof 변수명 사용하면 변수의 자료형을 문자로 내보내줌
union type 등의 이유로 어떤 변수의 타입이 아직 불확실하다면 if문 등으로 narrowing 해줘야 조작이 가능해짐
if문 썼으면 끝까지 써야 안전함 else나 else if 안쓰면 불완전할 수도 있음
속성명 in 오브젝트자료 / 인스턴스 instanceof 부모 등등도 다 narrowing에 속함
그냥 현재 변수의 타입이 뭔지 특정만 지을 수 있으면 narrowing으로 판정해줌
narrowing이 귀찮으면 assertion 문법을 써보던가
타입 덮어쓰는 형태의 문법임
변수명 as 자료형 (해당 변수를 해당 자료형으로 덮어씌워주세요) => 근데 그렇다고 변수의 자료형을 바꿀 수는 없음
assertion 문법의 용도가 뭐임?
1. narrowing 할 때 쓰기도 하고, 2. 무슨 타입이 100% 확실할 때 사용해야함
그래서 as 문법 사용하면 에러가 있어도 잡아주니까 잘 사용해야 함
그러니까 평소에는 잘 사용 안 함
코드짜다가 콘솔창에 변수 출력해보고 싶으면 html 파일 안에 ts 파일 변환시킨 js 파일을 넣어서 확인해보면 됨

type alias는 type을 저장하는 변수 문법임
type 변수명 = 저장하고자 하는 자료형들
union type도 저장되고 object 타입도 저장됨
type 변수 작명 관습으로는 영어대문자 국룰임
const에 대해 제대로 알고 있음?
const 쓰면 재할당이 불가능함
그래서 object를 const로 담으면 object의 수정이 가능함
근데 typescript를 쓰면 object의 자료 수정도 막을 수 있음
object 자료 수정을 막을려면 타입 지정할 때 막고 싶은 자료 앞에 readonly 지정하면 됨
{readonly 속성명 : 자료형}
참고: 타입스크립트 에러는 에디터와 터미널에서만 존재하고 실제로는 변환이 가능함
object 속성 안에서도 ?를 사용할 수 있음
그리고 type alias도 union type으로 병합 가능함
+ &연산자로 object 타입도 합칠 수 있음
타입변수1 & 타입변수2 를 통해 object 타입을 extend한다
같은 이름의 type 변수는 재정의 불가능함

사실 변수에 더 엄격한 타입 지정이 가능함
그걸 전문 용어로 literal types라고 함
자료형 적던 자리에 원하는 값을 넣으면 됨
이거 왜 쓰는데요?
변수에 뭐가 들어올지 더 엄격하게 관리 가능하잖음 + 자동완성도 도와줌
함수도 당연히 가능합니다
const 변수에 사실 한계가 있음
근데 생각해보면 const 변수를 업글한 게 literal type 아님?
그럼 const 변수처럼 유사하게 사용 가능한 거 아님?
근데 사실 literal type의 문제점이 존재함
literal type의 정확한 뜻은 ~~라는 자료만 들어올 수 있다가 아니라 ~~라는 타입만 들어올 수 있다임
그럼 저거 해결은 어케 함?
object 만들 때 타입 지정 확실하게 하든가 or as 문법 써서 타입 구라치던가 or as const라는 키워드를 object 끝에다가 붙이던가 (var 변수명 = {~~} as const)
as const? 1. object value 값을 그대로 타입으로 지정해주고 2. 속성들을 모두 readonly로 바꿔줌
as const를 쓰면 object 자료를 말그대로 잠글 수 있음

일반 함수는 타입 지정하는 방법 알고 있잖음
type alias에 함수의 전체 type을 저장할 수도 있음
type 타입명 = (파라미터 :자료형) => return자료형
저렇게 생성한 타입명 쓸려면 함수표현식이란 걸 써야함
let 함수명 :타입명 = function () {}
object 안에도 함수를 만들 수 있음
그럼 object 안에 있는 함수의 타입은 어케 지정함?
똑같이 하던 대로 하면 됨

정보 제공을 위해선 먼저 js 자료형에 먼저 모든 정보들을 담아놔야함
object 자료형으로 정리하기에는 코드가 너무 길어지지 않음?
그래서 class 문법을 사용하는 거임
class = object 뽑아내는 기계
function 클래스명() { this.속성명 = 값 ... };
요로케 생긴 거를 constructor라고 부름
this는 뭔데요? 그거는 기계로부터 생성되는 object임 (=instance)
new 클래스명() 으로 할당해주면 새로운 object가 생성됨
es6문법으로 적용시키면
class 클래스명 { constructor() { this.속성명 = 값 }}
이때 생성된 친구는 자식, 생성한 친구는 부모 관계가 됨

부모 자식 관계를 표현하기 위한 방법으로 prototype이라는 것도 있음
prototype은 유전자임
우리 키가 작은 이유는? 부모님 때문임
부모님의 키가 작아서가 아니라 부모님이 물려주신 유전자의 특징이 키가 작은 거니까 우리 키가 작은 거임
모든 object에는 prototype이라는게 존재함
class명.prototype.속성명 = 값 을 할당시키면 상속 기능 구현 가능함
class에 추가하면 자식들도 직접 가지고 있지만, prototype은 부모만 가지는 거임
부모 유전자에 있는 걸 자식이 사용할 수 있는 이유는?
1. 자식에서 찾아본다 2. 부모에서 찾아본다 3. 부모의 부모에서 찾아본다 .... (prototype chain)
이런 원리를 이해하면 다른 것들도 이해됨
[4,2,1] === new Array(4,2,1) -> Array라는 클래스를 불러온다
Array에서 .sort()를 쓸 수 있는 이유? Array라는 클래스의 prototype에 sort()라는 함수가 내장되어 있는 거임

당연히 ts로도 html 조작 가능한데 조금 다름
tsconfig.json에 "strictNullChecks": true 요거 추가하고 시작하셈
일반적으로 하던 대로 하면 타입들이 union type으로 되어 있을 수가 있기 때문에 type narrowing 잘 해야함
1. 타입명 != null 일 때 바꿔준다든지 등등
말고도 다른 방법도 많음
2. 쿼리선택자로있는변수명 instanceof Element (얘를 제일 많이 쓰게 됨)
3. 처음에 쿼리 선택자로 할당 받은 변수를 assertion 문법 써서 as Element로 바꾸기
근데 타입을 확정시킬거면 ts 왜 씀? 그래서 잘 안 씀
4. 오브젝트에 붙이는 ?. 라는 걸 붙이셈 (optional chaining)
4번을 붙이면 innerHTML이 있으면 붙이고 아니면 undefined를 내놓음
5. 가장 무식한 해결책은 아까 설정했던 tsconfig.json 그걸 원상태로 되돌릴 수 있음
ts 쓰면 좀 귀찮을 수는 있지만 이게 안전하잖음 이거 잘 하셈
ts가 제공하는 기본적인 타입들이 있음
Element(든 게 몇 개 없음) => 그래서 이걸 옆에 애들한테 상속시킴: HTMLAnchorElement, HTMLHeadingElement, HTMLButtonElement
eventlistener도 똑같음
붙일 때 ?. 이런 거 붙이면 쌉가능임

사실 class 안에서 constructor말고도 실제 데이터를 넣을 수 있음
그 친구를 class 필드값이라고 부름
class 필드 역시 타입 지정이 가능함
ts에서는 constructor 안에 속성을 설정하기 전에 필드값에서 타입 지정을 먼저 해줘야할 필요가 있음
constructor 파라미터 역시 타입 지정해줘야 함
constructor는 return 타입이 따로 없기 때문에 return에 대한 타입 지정은 필요가 없음
클래스 내에서도 내장 함수 생성 가능(prototype 때문에)
그럼 prototype 함수도 타입 지정 가능? 당연히 가능 + 원하면 return 타입도 지정 가능함

type 키워드로 타입 변수 생성 가능
interface 키워드로도 타입 변수 생성 가능함
object 타입 지정할 때 interface 사용 가능함
interface를 쓸 때의 장점이 뭐임?
extends로 복사가 가능해짐
interface 타입변수명 extends 확장시켜줄타입변수명
사실 type alias도 &로 유사한 기능 구현이 가능함 (&기호 = intersection type)
근데 유사하다고 표현한 이유는 &기호 쓰면 두 타입을 모두 만족하는 타입이여야 함
type vs interface
interface는 중복 선언이 가능하지만 type은 불가능함
interface는 유연하기 때문에 중복 선언을 해주면 자동으로 extends가 됨
근데 type은 엄격하기 때문에 중복 선언이 안 됨
외부 라이브러리는 interface로 도배되어 있음 유연하니까 내가 추후에 타입을 따로 더할 수도 있기 때문에 등등
만약에 extends 쓸 때 중복 속성이 존재하면 어떻게 됨? 에러남 알아서 잘 고치셈
근데 &기호 사용할 때 중복 속성이 존재하면 에러가 나지 않음 그럼 그 속성은 never 타입으로 바뀌니까 알아서 주의해야함
